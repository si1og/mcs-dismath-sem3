\section{Особенности реализации}

Программа реализована на языке C++. Архитектура построена на иерархии из четырёх классов: \texttt{CliUI}, \texttt{TruthTable}, \texttt{ZhegalkinPolynomial} и \texttt{BDD}.

\subsection{Структура проекта}

Проект разделён на следующие файлы:
\begin{itemize}
    \item \texttt{cli\_ui.h}~--- базовый класс консольного интерфейса;
    \item \texttt{truth\_table.h}~--- класс таблицы истинности с методами построения СДНФ и СКНФ;
    \item \texttt{zhegalkin.h}~--- класс полинома Жегалкина;
    \item \texttt{bdd.h}~--- класс бинарной диаграммы решений;
    \item \texttt{main.cpp}~--- главный файл программы с меню.
\end{itemize}

Иерархия наследования классов:
\begin{center}
\texttt{CliUI} $\rightarrow$ \texttt{TruthTable} $\rightarrow$ \texttt{ZhegalkinPolynomial} $\rightarrow$ \texttt{BDD}
\end{center}

\subsection{Класс CliUI}

Базовый класс, предоставляющий методы для работы с консольным интерфейсом.

\subsubsection*{Структура данных}

\begin{lstlisting}[language=C++, caption=Класс CliUI, basicstyle=\footnotesize\ttfamily]
class CliUI {
protected:
    void printHeader(const std::string& title) const;
    void printSeparator() const;
    int getUserInput(const std::string& prompt, int minVal, int maxVal) const;
public:
    virtual ~CliUI() = default;
};
\end{lstlisting}

\subsubsection*{Метод printHeader}

Выводит заголовок раздела в консоль.
\begin{itemize}
    \item \textbf{Вход:} строка заголовка.
    \item \textbf{Выход:} форматированный заголовок в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод printHeader, basicstyle=\footnotesize\ttfamily]
void printHeader(const std::string& title) const {
    std::cout << "\n" << std::string(50, '=') << "\n";
    std::cout << title << "\n";
    std::cout << std::string(50, '=') << "\n";
}
\end{lstlisting}

\subsubsection*{Метод printSeparator}

Выводит горизонтальную линию-разделитель.
\begin{itemize}
    \item \textbf{Вход:} консольное окружение.
    \item \textbf{Выход:} линия из 50 символов <<->> в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод printSeparator, basicstyle=\footnotesize\ttfamily]
void printSeparator() const {
    std::cout << std::string(50, '-') << "\n";
}
\end{lstlisting}

\subsubsection*{Метод getUserInput}

Запрашивает целое число у пользователя с валидацией.
\begin{itemize}
    \item \textbf{Вход:} текст приглашения, минимальное и максимальное допустимые значения.
    \item \textbf{Выход:} корректное целое число в заданном диапазоне.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод getUserInput, basicstyle=\footnotesize\ttfamily]
int getUserInput(const std::string& prompt, int minVal, int maxVal) const {
    int value;
    while (true) {
        std::cout << prompt;
        if (std::cin >> value && value >= minVal && value <= maxVal) {
            return value;
        }
        std::cin.clear();
        std::cin.ignore(10000, '\n');
        std::cout << "Ошибка! Введите число от " << minVal 
                  << " до " << maxVal << "\n";
    }
}
\end{lstlisting}

\subsection{Класс TruthTable}

Класс для хранения и отображения таблицы истинности булевой функции, а также построения СДНФ и СКНФ.

\subsubsection*{Структура данных}

\begin{lstlisting}[language=C++, caption=Поля класса TruthTable, basicstyle=\footnotesize\ttfamily]
class TruthTable : public CliUI {
protected:
    int numVars;              // количество переменных
    std::vector<int> values;  // вектор значений функции
    
    void printTruthTable() const;
public:
    TruthTable(int n, const std::vector<int>& vals);
    
    void displayTable();
    void displaySDNF();
    void displaySKNF();
    int evaluate(const std::vector<int>& input) const;
    
    int getNumVars() const;
    const std::vector<int>& getValues() const;
};
\end{lstlisting}

\subsubsection*{Конструктор}

Создаёт таблицу истинности.
\begin{itemize}
    \item \textbf{Вход:} количество переменных $n$, вектор значений функции размером $2^n$.
    \item \textbf{Выход:} инициализированный объект таблицы истинности.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Конструктор TruthTable, basicstyle=\footnotesize\ttfamily]
TruthTable(int n, const std::vector<int>& vals) : numVars(n), values(vals) {}
\end{lstlisting}

\subsubsection*{Метод printTruthTable}

Выводит таблицу истинности в табличном формате.
\begin{itemize}
    \item \textbf{Вход:} поля \texttt{numVars} и \texttt{values}.
    \item \textbf{Выход:} форматированная таблица в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод printTruthTable, basicstyle=\footnotesize\ttfamily]
void printTruthTable() const {
    std::cout << "| № |";
    for (int i = 1; i <= numVars; ++i) {
        std::cout << " x" << i << " |";
    }
    std::cout << " f |\n";

    std::cout << "|---|";
    for (int i = 0; i < numVars; ++i) {
        std::cout << "----|";
    }
    std::cout << "---|\n";

    int numRows = 1 << numVars;
    for (int i = 0; i < numRows; ++i) {
        std::cout << "|" << std::setw(2) << i << " |";
        for (int j = numVars - 1; j >= 0; --j) {
            std::cout << "  " << ((i >> j) & 1) << " |";
        }
        std::cout << " " << values[i] << " |\n";
    }
}
\end{lstlisting}

\subsubsection*{Метод displayTable}

Выводит таблицу истинности с заголовком.
\begin{itemize}
    \item \textbf{Вход:} консольное окружение.
    \item \textbf{Выход:} заголовок и таблица истинности в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод displayTable, basicstyle=\footnotesize\ttfamily]
void displayTable() {
    printHeader("ТАБЛИЦА ИСТИННОСТИ");
    printTruthTable();
}
\end{lstlisting}

\subsubsection*{Метод displaySDNF}

Выводит совершенную дизъюнктивную нормальную форму.
\begin{itemize}
    \item \textbf{Вход:} вектор значений функции.
    \item \textbf{Выход:} строка СДНФ в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод displaySDNF, basicstyle=\footnotesize\ttfamily]
void displaySDNF() {
    printHeader("СДНФ");
    std::string sdnf;
    bool first = true;
    int numRows = 1 << numVars;

    for (int i = 0; i < numRows; ++i) {
        if (values[i] == 1) {
            if (!first) sdnf += " or ";
            first = false;

            std::string term;
            for (int j = numVars - 1; j >= 0; --j) {
                if (!term.empty()) term += "^";
                if ((i >> j) & 1) {
                    term += "x" + std::to_string(numVars - j);
                } else {
                    term += "!x" + std::to_string(numVars - j);
                }
            }
            sdnf += "(" + term + ")";
        }
    }
    std::cout << "f = " << (sdnf.empty() ? "0" : sdnf) << "\n";
}
\end{lstlisting}

Алгоритм построения СДНФ: для каждого набора, на котором функция равна 1, формируется конъюнкция литералов. Переменная входит без отрицания, если соответствующий бит равен 1, и с отрицанием~--- если 0.

\subsubsection*{Метод displaySKNF}

Выводит совершенную конъюнктивную нормальную форму.
\begin{itemize}
    \item \textbf{Вход:} вектор значений функции.
    \item \textbf{Выход:} строка СКНФ в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод displaySKNF, basicstyle=\footnotesize\ttfamily]
void displaySKNF() {
    printHeader("СКНФ");
    std::string sknf;
    bool first = true;
    int numRows = 1 << numVars;

    for (int i = 0; i < numRows; ++i) {
        if (values[i] == 0) {
            if (!first) sknf += " ^ ";
            first = false;

            std::string clause;
            for (int j = numVars - 1; j >= 0; --j) {
                if (!clause.empty()) clause += "or";
                if ((i >> j) & 1) {
                    clause += "!x" + std::to_string(numVars - j);
                } else {
                    clause += "x" + std::to_string(numVars - j);
                }
            }
            sknf += "(" + clause + ")";
        }
    }
    std::cout << "f = " << (sknf.empty() ? "1" : sknf) << "\n";
}
\end{lstlisting}

Алгоритм построения СКНФ: для каждого набора, на котором функция равна 0, формируется дизъюнкция литералов. Переменная входит с отрицанием, если соответствующий бит равен 1, и без отрицания~--- если 0.

\subsubsection*{Метод evaluate}

Вычисляет значение функции на заданном наборе.
\begin{itemize}
    \item \textbf{Вход:} вектор значений переменных $\{x_1, x_2, \ldots, x_n\}$.
    \item \textbf{Выход:} значение функции (0 или 1).
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод evaluate, basicstyle=\footnotesize\ttfamily]
int evaluate(const std::vector<int>& input) const {
    int index = 0;
    for (int i = 0; i < numVars; ++i) {
        index = (index << 1) | input[i];
    }
    return values[index];
}
\end{lstlisting}

Индекс в таблице истинности вычисляется как двоичное число, составленное из значений переменных.

\subsubsection*{Геттеры}

\begin{lstlisting}[language=C++, caption=Геттеры класса TruthTable, basicstyle=\footnotesize\ttfamily]
int getNumVars() const { return numVars; }
const std::vector<int>& getValues() const { return values; }
\end{lstlisting}

\subsection{Класс ZhegalkinPolynomial}

Класс для построения и вычисления полинома Жегалкина методом треугольника Паскаля.

\subsubsection*{Структура данных}

\begin{lstlisting}[language=C++, caption=Поля класса ZhegalkinPolynomial, basicstyle=\footnotesize\ttfamily]
class ZhegalkinPolynomial : public TruthTable {
private:
    std::vector<int> coefficients;
    
    void buildCoefficients();
public:
    ZhegalkinPolynomial(int n, const std::vector<int>& vals);
    
    void displayPolynomial();
    int evaluatePolynomial(const std::vector<int>& input) const;
    void interactiveEvaluate();
};
\end{lstlisting}

\subsubsection*{Конструктор}

Создаёт объект полинома Жегалкина и вычисляет коэффициенты.
\begin{itemize}
    \item \textbf{Вход:} количество переменных $n$, вектор значений функции.
    \item \textbf{Выход:} инициализированный объект с вычисленными коэффициентами.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Конструктор ZhegalkinPolynomial, basicstyle=\footnotesize\ttfamily]
ZhegalkinPolynomial(int n, const std::vector<int>& vals) : TruthTable(n, vals) {
    buildCoefficients();
}
\end{lstlisting}

\subsubsection*{Метод buildCoefficients}

Вычисляет коэффициенты полинома методом треугольника Паскаля.
\begin{itemize}
    \item \textbf{Вход:} вектор значений функции.
    \item \textbf{Выход:} заполненный вектор коэффициентов.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод buildCoefficients, basicstyle=\footnotesize\ttfamily]
void buildCoefficients() {
    int numRows = 1 << numVars;
    std::vector<std::vector<int>> triangle(numRows);

    triangle[0] = values;

    for (int i = 1; i < numRows; ++i) {
        triangle[i].resize(numRows - i);
        for (int j = 0; j < numRows - i; ++j) {
            triangle[i][j] = triangle[i-1][j] ^ triangle[i-1][j+1];
        }
    }

    coefficients.resize(numRows);
    for (int i = 0; i < numRows; ++i) {
        coefficients[i] = triangle[i][0];
    }
}
\end{lstlisting}

Алгоритм строит треугольник, где каждый элемент равен XOR двух соседних элементов предыдущей строки. Коэффициенты полинома~--- первые элементы каждой строки.

\subsubsection*{Метод displayPolynomial}

Выводит полином Жегалкина в консоль.
\begin{itemize}
    \item \textbf{Вход:} вектор коэффициентов.
    \item \textbf{Выход:} строковое представление полинома в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод displayPolynomial, basicstyle=\footnotesize\ttfamily]
void displayPolynomial() {
    printHeader("ПОЛИНОМ ЖЕГАЛКИНА");

    std::string result;
    int numRows = 1 << numVars;
    bool first = true;

    for (int i = 0; i < numRows; ++i) {
        if (coefficients[i] == 1) {
            if (!first) result += " + ";
            first = false;

            if (i == 0) {
                result += "1";
            } else {
                std::string term;
                for (int j = 0; j < numVars; ++j) {
                    if ((i >> (numVars - 1 - j)) & 1) {
                        term += "x" + std::to_string(j + 1);
                    }
                }
                result += term;
            }
        }
    }

    std::cout << "f = " << (result.empty() ? "0" : result) << "\n";
}
\end{lstlisting}

\subsubsection*{Метод evaluatePolynomial}

Вычисляет значение полинома Жегалкина на заданном наборе.
\begin{itemize}
    \item \textbf{Вход:} вектор значений переменных.
    \item \textbf{Выход:} значение полинома (0 или 1).
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод evaluatePolynomial, basicstyle=\footnotesize\ttfamily]
int evaluatePolynomial(const std::vector<int>& input) const {
    int result = 0;
    int numRows = 1 << numVars;

    for (int i = 0; i < numRows; ++i) {
        if (coefficients[i] == 1) {
            int term = 1;
            for (int j = 0; j < numVars; ++j) {
                if ((i >> (numVars - 1 - j)) & 1) {
                    term &= input[j];
                }
            }
            result ^= term;
        }
    }
    return result;
}
\end{lstlisting}

Для каждого ненулевого коэффициента вычисляется соответствующий моном (произведение переменных), затем все мономы складываются по модулю 2.

\subsubsection*{Метод interactiveEvaluate}

Интерактивное вычисление полинома с вводом значений переменных от пользователя.
\begin{itemize}
    \item \textbf{Вход:} значения переменных от пользователя.
    \item \textbf{Выход:} результат вычисления в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод interactiveEvaluate, basicstyle=\footnotesize\ttfamily]
void interactiveEvaluate() {
    printHeader("ВЫЧИСЛЕНИЕ ПО ПОЛИНОМУ ЖЕГАЛКИНА");

    std::vector<int> input(numVars);
    std::cout << "Введите значения переменных:\n";
    for (int i = 0; i < numVars; ++i) {
        input[i] = getUserInput("x" + std::to_string(i + 1) + " (0 или 1): ", 0, 1);
    }

    int result = evaluatePolynomial(input);
    std::cout << "\nf(";
    for (int i = 0; i < numVars; ++i) {
        if (i > 0) std::cout << ", ";
        std::cout << input[i];
    }
    std::cout << ") = " << result << "\n";
}
\end{lstlisting}

\subsection{Класс BDD}

Класс для хранения и вычисления бинарной диаграммы решений.

\subsubsection*{Структура узла}

\begin{lstlisting}[language=C++, caption=Структура узла БДР, basicstyle=\footnotesize\ttfamily]
struct BDDNode {
    int varIndex;   // индекс переменной (-1 для листа)
    int value;      // значение листа (0 или 1)
    int low;        // индекс потомка по ребру 0
    int high;       // индекс потомка по ребру 1
};
\end{lstlisting}

\subsubsection*{Структура класса}

\begin{lstlisting}[language=C++, caption=Поля класса BDD, basicstyle=\footnotesize\ttfamily]
class BDD : public ZhegalkinPolynomial {
private:
    std::vector<BDDNode> nodes;
    int root;
    
    void buildHardcodedBDD();
public:
    BDD(int n, const std::vector<int>& vals);
    
    void displayBDD();
    int evaluateBDD(const std::vector<int>& input) const;
    void interactiveEvaluateBDD();
};
\end{lstlisting}

\subsubsection*{Конструктор}

Создаёт объект БДР и строит диаграмму.
\begin{itemize}
    \item \textbf{Вход:} количество переменных $n$, вектор значений функции.
    \item \textbf{Выход:} инициализированный объект с построенной БДР.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Конструктор BDD, basicstyle=\footnotesize\ttfamily]
BDD(int n, const std::vector<int>& vals) : ZhegalkinPolynomial(n, vals) {
    buildHardcodedBDD();
}
\end{lstlisting}

\subsubsection*{Метод buildHardcodedBDD}

Строит БДР для заданной функции с порядком переменных $x_1, x_4, x_2, x_3$.
\begin{itemize}
    \item \textbf{Вход:} нет (структура задана для конкретной функции).
    \item \textbf{Выход:} заполненный вектор узлов и установленный корень.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод buildHardcodedBDD, basicstyle=\footnotesize\ttfamily]
void buildHardcodedBDD() {
    nodes.push_back({-1, 0, -1, -1});  // [0] лист 0
    nodes.push_back({-1, 1, -1, -1});  // [1] лист 1

    nodes.push_back({2, 0, 0, 1});     // [2] x3
    nodes.push_back({1, 0, 2, 1});     // [3] x2
    nodes.push_back({1, 0, 0, 2});     // [4] x2
    nodes.push_back({3, 0, 3, 4});     // [5] x4
    nodes.push_back({0, 0, 5, 4});     // [6] x1

    root = 6;
}
\end{lstlisting}

БДР содержит 7 узлов: 2 листа и 5 внутренних узлов. Узел [4] используется повторно, что обеспечивает компактность представления.

\subsubsection*{Метод displayBDD}

Выводит структуру БДР в консоль.
\begin{itemize}
    \item \textbf{Вход:} вектор узлов.
    \item \textbf{Выход:} список узлов с их связями в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод displayBDD, basicstyle=\footnotesize\ttfamily]
void displayBDD() {
    printHeader("БИНАРНАЯ ДИАГРАММА РЕШЕНИЙ (БДР)");

    std::cout << "Порядок переменных: x1, x4, x2, x3\n\n";
    std::cout << "Структура БДР:\n";
    printSeparator();

    for (size_t i = 0; i < nodes.size(); ++i) {
        std::cout << "  [" << i << "] ";
        if (nodes[i].varIndex == -1) {
            std::cout << "Лист: " << nodes[i].value << "\n";
        } else {
            std::cout << "x" << (nodes[i].varIndex + 1)
                      << " --0--> [" << nodes[i].low << "]"
                      << ", --1--> [" << nodes[i].high << "]\n";
        }
    }

    std::cout << "\nКорень: [" << root << "]\n";
    std::cout << "Всего узлов: " << nodes.size() << "\n";
}
\end{lstlisting}

\subsubsection*{Метод evaluateBDD}

Вычисляет значение функции по БДР.
\begin{itemize}
    \item \textbf{Вход:} вектор значений переменных.
    \item \textbf{Выход:} значение функции (0 или 1).
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод evaluateBDD, basicstyle=\footnotesize\ttfamily]
int evaluateBDD(const std::vector<int>& input) const {
    int current = root;
    while (nodes[current].varIndex != -1) {
        int var = nodes[current].varIndex;
        current = (input[var] == 0) ? nodes[current].low : nodes[current].high;
    }
    return nodes[current].value;
}
\end{lstlisting}

Алгоритм начинает с корня и на каждом шаге выбирает потомка в зависимости от значения соответствующей переменной, пока не достигнет листа.

\subsubsection*{Метод interactiveEvaluateBDD}

Интерактивное вычисление по БДР с выводом пути.
\begin{itemize}
    \item \textbf{Вход:} значения переменных от пользователя.
    \item \textbf{Выход:} путь по диаграмме и результат в консоли.
\end{itemize}

\begin{lstlisting}[language=C++, caption=Метод interactiveEvaluateBDD, basicstyle=\footnotesize\ttfamily]
void interactiveEvaluateBDD() {
    printHeader("ВЫЧИСЛЕНИЕ ПО БДР");

    std::vector<int> input(numVars);
    std::cout << "Введите значения переменных:\n";
    for (int i = 0; i < numVars; ++i) {
        input[i] = getUserInput("x" + std::to_string(i + 1) + " (0 или 1): ", 0, 1);
    }

    std::cout << "\nПуть по БДР:\n";
    int current = root;
    while (nodes[current].varIndex != -1) {
        int var = nodes[current].varIndex;
        std::cout << "  x" << (var + 1) << " = " << input[var];
        if (input[var] == 0) {
            std::cout << " --0--> [" << nodes[current].low << "]\n";
            current = nodes[current].low;
        } else {
            std::cout << " --1--> [" << nodes[current].high << "]\n";
            current = nodes[current].high;
        }
    }

    std::cout << "\nРезультат: f(";
    for (int i = 0; i < numVars; ++i) {
        if (i > 0) std::cout << ", ";
        std::cout << input[i];
    }
    std::cout << ") = " << nodes[current].value << "\n";
}
\end{lstlisting}

\subsection{Главная функция}

Файл \texttt{main.cpp} содержит определение функции и главный цикл меню.

\begin{lstlisting}[language=C++, caption=Главная функция, basicstyle=\footnotesize\ttfamily]
#include "bdd.h"

int main() {
    std::vector<int> functionVector = {
        0, 0, 1, 0,  
        1, 0, 1, 1,
        0, 0, 0, 0,
        0, 0, 1, 1 
    };

    BDD func(4, functionVector);

    while (true) {
        std::cout << "\n";
        std::cout << "╔════════════════════════════════════════════════╗\n";
        std::cout << "║                    МЕНЮ                        ║\n";
        std::cout << "════════════════════════════════════════════════\n";
        std::cout << "║  1. Таблица истинности                         ║\n";
        std::cout << "║  2. СДНФ                                       ║\n";
        std::cout << "║  3. СКНФ                                       ║\n";
        std::cout << "║  4. Полином Жегалкина                          ║\n";
        std::cout << "║  5. БДР                                        ║\n";
        std::cout << "║  6. Вычислить по полиному Жегалкина            ║\n";
        std::cout << "║  7. Вычислить по БДР                           ║\n";
        std::cout << "║  0. Выход                                      ║\n";
        std::cout << "╚════════════════════════════════════════════════╝\n";
        std::cout << "Выбор: ";

        int choice;
        std::cin >> choice;

        switch (choice) {
            case 1:
                func.displayTable();
                break;
            case 2:
                func.displaySDNF();
                break;
            case 3:
                func.displaySKNF();
                break;
            case 4:
                func.displayPolynomial();
                break;
            case 5:
                func.displayBDD();
                break;
            case 6:
                func.interactiveEvaluate();
                break;
            case 7:
                func.interactiveEvaluateBDD();
                break;
            case 0:
                std::cout << "До свидания!\n";
                return 0;
            default:
                std::cout << "Неверный выбор!\n";
        }
    }

    return 0;
}
\end{lstlisting}

Функция задаётся вектором из 16 значений, соответствующих наборам от 0000 до 1111.